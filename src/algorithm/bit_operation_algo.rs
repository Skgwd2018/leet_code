/// 338.比特位计数(位运算,动态规划)
/// 位运算
// 输入: n = 5
// 输出: [0,1,1,2,1,2]
// 解释:
// 0 --> 0
// 1 --> 1
// 2 --> 10
// 3 --> 11
// 4 --> 100
// 5 --> 101
pub fn count_bits(n: i32) -> Vec<i32> {
    // count_ones() 方法:计算其二进制表示中1的个数
    // count_ones() 函数是std::u32::TrailingZeroBits trait的一部分,适用于所有(有/无符号)整数类型(包括u8 ~ u128 & i8 ~ i128)
    (0..=n).map(|x| x.count_ones() as i32).collect()
}
//-----------------------------------------------------

/// 136.只出现一次的数字(位运算,数组)
// 题目:给你一个 非空 整数数组 nums,除了某个元素只出现一次以外,其余每个元素均出现两次。找出那个只出现了一次的元素。
// 假设数组中重复的元素为x,只出现一次的元素为y。
// 将数组中的所有元素进行异或运算,由于x出现了两次,所以x和x异或的结果为0,而y只出现了一次,所以最后的结果就是y。
/// 异或（XOR）运算问题。异或运算有一个重要的性质:任何数和0异或都等于它本身,任何数和其自身异或都等于0。
pub fn single_number(nums: Vec<i32>) -> i32 {
    /*let mut single = 0;
    nums.iter().for_each(|num| single ^= num);
    single*/

    // 解法二:
    // reduce() 和 fold() 在功能上是相似的,但它们的初始值和参数的顺序是不同的。
    // 两者都可以用来累积一个值,通过对集合中的元素应用某种操作。
    // 对于 reduce() 方法,它接受一个二元操作函数,并将集合中的元素两两组合起来,直到只剩下一个元素。
    // reduce() 不需要初始值,因为它使用集合中的第一个元素作为初始值。
    // 注:reduce() 使用数组中的第一个元素作为初始值进行异或操作;
    // 如果数组为空, reduce() 会返回一个 None,需要使用 unwrap() 来获取结果,这可能会导致运行时错误(如果数组为空)。
    // 在这种情况下, reduce() 运行更高效
    // nums.into_iter().reduce(|x, y| x ^ y).unwrap()
    nums.iter().fold(0, |single, num| single ^ num)
}
//-----------------------------------------------------

/// 1318.或运算的最小翻转次数(位运算)
// 给定三个正整数 a、b 和 c; 可以对 a 和 b 的二进制表示进行位翻转操作,返回能够使按位或运算 a OR b == c 成立的最小翻转次数。
// 「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1
// 输入: a = 2, b = 6, c = 5
// 输出: 3
// 解释: 翻转后 a = 1 , b = 4 , c = 5 使得 a OR b == c
pub fn min_flips(a: i32, b: i32, c: i32) -> i32 {
    /*let mut answer = 0;
    for i in 0..32 {
        let (a_i, b_i, c_i) = ((a >> i) & 1, (b >> i) & 1, (c >> i) & 1);
        if c_i == 0 {
            answer += a_i + b_i;
        } else if a_i + b_i == 0 {
            answer += 1;
        }
    }
    answer*/

    // 解法二:
    /*let mut answer = 0;
    for i in 0..(32 - c.leading_zeros()).max(32 - a.leading_zeros()).max(32 - b.leading_zeros()) {
        if ((a | b) >> i) & 1 != (c >> i & 1) {
            answer += if c >> i & 1 == 1 { 1 } else { (a >> i & 1) + (b >> i & 1) }
        }
    }
    answer*/

    // 解法三:
    i32::try_from(((a | b) ^ c).count_ones() + ((a & b) & !c).count_ones()).expect("i32 error")
}
//-----------------------------------------------------

/// 526.优美的排列(位运算+动态规划,回溯,状态压缩)
// 假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm(下标从 1 开始),只要满足下述条件 之一,该数组就是一个 优美的排列:
// perm[i] 能够被 i 整除
// i 能够被 perm[i] 整除
// 给定一个整数 n, 返回可以构造的 优美排列 的 数量。
// 输入: n = 2
// 输出: 2
// 解释:
// 第 1 个优美的排列是 [1, 2]:
//     - perm[1] = 1 能被 i = 1 整除
//     - perm[2] = 2 能被 i = 2 整除
// 第 2 个优美的排列是 [2, 1]:
//     - perm[1] = 2 能被 i = 1 整除
//     - i = 2 能被 perm[2] = 1 整除
pub fn count_arrangement(n: i32) -> i32 {
    let mut f = vec![0; 1 << n];
    f[0] = 1;
    for s in 1..f.len() {
        let i = s.count_ones() as i32;
        for j in 1..=n {
            if (s >> (j - 1) & 1) != 0 && (i % j == 0 || j % i == 0) {
                f[s] += f[s ^ (1 << (j - 1))];
            }
        }
    }

    f[f.len() - 1]
}
//-----------------------------------------------------